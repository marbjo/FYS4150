\documentclass{emulateapj}
%\documentclass[12pt,preprint]{aastex}

\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{epsfig,floatflt}
\usepackage{hyperref}
\usepackage[toc, page]{appendix}
\usepackage{verbatim, amsmath, amsfonts, amssymb, amsthm}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{float}
\usepackage{xcolor}
\usepackage{color}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage[export]{adjustbox}
\usepackage{calc}

\usepackage{accents}
\newcommand{\dbtilde}[1]{\accentset{\approx}{#1}}
\newcommand{\vardbtilde}[1]{\tilde{\raisebox{0pt}[0.85\height]{$\tilde{#1}$}}}

\usepackage{lipsum}
\usepackage[para]{footmisc}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
	backgroundcolor=\color{white}\ttfamily\tiny,   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\tiny,        % the size of the fonts that are used for the code \footnotesize,
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	columns=fullflexible,    %no spaces between columns
	keepspaces=true,
	breaklines=true,                 % sets automatic line breaking
	breakatwhitespace=true,
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	deletekeywords={...},            % if you want to delete keywords from the given language
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	frame=single,	                   % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue},       % keyword style
	language=Python,                 % the language of the code
	morekeywords={*,...},           % if you want to add more keywords to the set
	%numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	%numbersep=5pt,                   % how far the line-numbers are from the code
	%numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=1,	                   % sets default tabsize to 2 spaces
	%title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}

\title{Comparing efficiency of different algorithms for solving sets of linear equations}

\author{Markus Bj√∏rklund}

\email{markus.bjorklund@astro.uio.no}

\altaffiltext{1}{Institute of Theoretical Astrophysics, University of
  Oslo, P.O.\ Box 1029 Blindern, N-0315 Oslo, Norway}

\begin{abstract}
In this letter I analyze and compare the efficiency of a general, tailored and a LU-decomposition algorithm to solve a set of linear equations. The problem I will focus on is a discretized approximation to the one dimensional Poisson equation. The results show that, for n equations, we get $8n-7$ floating point operations (FLOPS) for the general algorithm, $4n-3$ FLOPS for the tailored algorithm and $\frac{2}{3}n^3$ FLOPS for the LU-decomposition method. I found that the optimal step length is $h=10^{-7}$. The results also show that the LU decomposition can not handle cases where the matrix is bigger or equal to $n=10^5$, whilst the other algorithms handle this very well.

\end{abstract}
\keywords{Algorithm efficiency --- Linear algebra: simulation --- methods: computational}

\section{Introduction}
\label{sec:introduction}
Solving differential equations is an integral part of most research today. For most differential equations there exists no analytic solution, so we have to use a computational approach. Generally, the more realistic the model is, the more complex it is, and therefore more computationally demanding. There would be a lot to gain to increase efficiency on the algorithms used to solve such equations.

In this letter I will adopt a numerical approach to solving the one dimensional Poisson equation, which shows up in numerous areas of science.

\section{Method}
\label{sec:method}
This section will describe the methods we utilized to acquire our results.
\subsection{Unitary transformations}
Unitary or orthogonal transformations have the property of conserving the dot product and orthogonality. We will show this for orthogonal matrices, but the argument extends to unitary transformations in the complex domain.

Suppose we have two vectors $\bold{v}_i$ and $\bold{v}_j$. Now, if we consider a orthogonal matrix $\bold{U}$, it has the property that $\bold{U}^T = \bold{U}^{-1}$ such that $\bold{U}^T\bold{U} = \bold{U}\bold{U}^T = \bold{I}$. Applying the transformation, we get new vectors $\bold{w}_i = \bold{U}\bold{v}_i$ and $ \bold{w}_j = \bold{U}\bold{v}_j$.
Now let's consider the dot product between these new vectors:

\begin{align*}
	\bold{w}_i \boldsymbol{\cdot} \bold{w}_j &= \left(\bold{U}\bold{v}_i\right) \boldsymbol{\cdot} \left(\bold{U}\bold{v}_j\right) \\
	&= \left(\bold{U}\bold{v}_i\right)^T \left(\bold{U}\bold{v}_j\right) \\
	&= \bold{U}^T \bold{v}_i^T \bold{U}\bold{v}_j \\
	&= \bold{v}_i^T  \bold{v}_j \bold{U}^T \bold{U} \\
	&= \bold{v}_i^T  \bold{v}_j \bold{I},
\end{align*}
which finally gives us

\begin{equation} \label{eq:dot}
	\bold{w}_i \boldsymbol{\cdot} \bold{w}_j = \bold{v}_i \boldsymbol{\cdot} \bold{v}_j.
\end{equation}


This shows the dot product is conserved. If we also assume that $\bold{v}_i$ and $\bold{v}_j$ is part of an orthogonal basis, such that $\bold{v}_i \boldsymbol{\cdot} \bold{v}_j = \delta_{ij}$, then we from equation \ref{eq:dot} that $\bold{w}_i \boldsymbol{\cdot} \bold{w}_j = \delta_{ij}$ is also true.


\section{Results}
\label{sec:results}





\section{Conclusions}
\label{sec:conclusions}
The results in this letter shows that when faced with a set of linear equations, one has a lot to gain to tailor your algorithm to the special case you are dealing with. Saving CPU time by a factor of 2 is substantial, and comparing to the LU-decomposition, for which the CPU time differs by a factor of $~n^2$, tailoring the algorithm is absolutely essential.

We have also seen that for some cases, the problem is not even solvable by the standard LU-decomposition. For matrices with $n=10^5$ or above, we did not have enough memory to perform the algorithm. However, the tailored methods work just fine, since we do not have to construct a whole matrix.

\subsection{Further research}
In this letter we have focused on the Poisson equation, with a specific second order approximation. However, similar analysis can be done for several other types of equations, or different approximations. There would be a lot to gain by gaining as efficient methods as possible for each specific case, so that bigger and more complex systems can be simulated and analyzed.

\begin{thebibliography}{}
\bibitem[(Hjorth-Jensen, 2018)]{MHJ} Hjorth-Jensen, Morten \, Sep 6 2018, "Computational Physics Lectures: Linear Algebra"
methods, http://compphysics.github.io/ComputationalPhysics/doc/pub/linalg/pdf/linalg-beamer.pdf

\end{thebibliography}

\section{Appendix}
All source codes and figures used can be found at the github repository: https://github.com/marbjo/FYS4150

\end{document}
